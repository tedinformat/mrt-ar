<script>
      document.addEventListener("DOMContentLoaded", function() {
        const guideUI = document.querySelector('#guide-ui');
        const photoUI = document.querySelector('#photo-ui');
        const shutterBtn = document.querySelector('#shutterBtn');
        const target = document.querySelector('#mytarget');
        const sceneEl = document.querySelector('a-scene');

        // UI 控制事件 (維持不變)
        target.addEventListener("targetFound", event => {
          guideUI.style.display = 'none';
          photoUI.style.display = 'flex';
        });
        target.addEventListener("targetLost", event => {
          guideUI.style.display = 'flex';
          photoUI.style.display = 'none';
        });

        // --- 修正後的拍照核心邏輯 ---
        shutterBtn.addEventListener('click', function() {
          
          // 1. 檢查必要元素是否存在
          const video = document.querySelector('video'); 
          const arCanvas = sceneEl.canvas;
          if (!video || !arCanvas) return;

          // 2. 暫時隱藏按鈕
          photoUI.style.display = 'none';

          // 3. 使用 requestAnimationFrame 確保在畫面渲染的當下進行截圖
          // 這比 setTimeout 更能確保抓到有內容的畫布
          requestAnimationFrame(() => {
              
              // 建立合併用的畫布，大小以攝影機影片為準
              const mergeCanvas = document.createElement('canvas');
              mergeCanvas.width = video.videoWidth;
              mergeCanvas.height = video.videoHeight;
              const ctx = mergeCanvas.getContext('2d');

              // --- 步驟 A: 繪製背景 (攝影機) ---
              // 將影片填滿整個畫布
              ctx.drawImage(video, 0, 0, mergeCanvas.width, mergeCanvas.height);

              // --- 步驟 B: 繪製前景 (AR圖案) [關鍵修正!] ---
              // 我們必須使用 9 個參數的 drawImage 方法，明確指定來源畫布的尺寸。
              // 這樣在 Retina 螢幕上，才能將高解析度的 AR 畫布正確縮放到照片上。
              // 參數格式: drawImage(來源, 來源X, 來源Y, 來源寬, 來源高, 目標X, 目標Y, 目標寬, 目標高)
              ctx.drawImage(
                  arCanvas, 
                  0, 0, arCanvas.width, arCanvas.height, // 來源端：抓取完整的 AR 畫布原始尺寸
                  0, 0, mergeCanvas.width, mergeCanvas.height // 目標端：縮放到符合照片的尺寸
              );

              // --- 步驟 C: 下載圖片 ---
              // 轉換為高品質 JPEG (相容性較好)
              const dataURL = mergeCanvas.toDataURL('image/jpeg', 0.95);
              
              const link = document.createElement('a');
              link.download = 'mrt-ar-photo.jpg';
              link.href = dataURL;
              link.click();

              // 恢復按鈕顯示
              photoUI.style.display = 'flex';
          });
        });

      });
    </script>
